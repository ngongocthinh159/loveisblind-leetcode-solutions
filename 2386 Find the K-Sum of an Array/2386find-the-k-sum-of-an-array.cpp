/**
https://stackoverflow.com/questions/33219712/find-k-th-minimum-sum-of-every-possible-subset/33220735#33220735

https://github.com/wisdompeak/LeetCode/tree/master/Priority_Queue/2386.Find-the-K-Sum-of-an-Array
2386.Find-the-K-Sum-of-an-Array
This is a really hard question.

Step 1: Convert it to finding the kth smallest sequence sum of a positive array.
Obviously, the sequence S with the largest sum in this question is to take out all the positive numbers in the array, which corresponds to MaxSum. The second largest sum value must be based on this sequence S minus an existing positive number, or adding a negative number that has not yet been queued. Similarly, the kth largest sum value must also be subtracting several existing positive numbers from this sequence S, or adding several negative numbers that have not yet been queued. Because subtracting a positive number is equal to subtracting its absolute value, and adding a negative number is also equal to subtracting its absolute value, the kth largest sum value is equivalent to subtracting the absolute value of several elements in nums from S (i.e. MaxSum). Therefore, we only need to pick out the kth smallest sequence sum in the absolute value array of nums.

Step 2: Construct the sum of all sequences from small to large of a positive array.
Here is the construction steps. The empty set must correspond to the smallest sequence sum, so we deal with it separately. Then

Put {nums[0], 0} into a small top heap (i.e., a priority queue that pops out the smallest value first).
If {sum, i} is popped out from PQ (where sum must be the sum of a subsequence ending with nums[i]), then add {sum-nums[i]+nums[i+1], i+1} and {sum+nums[i+1], i+1} to PQ (remembered as operations 1 and 2)
The sum popped out of PQ at the k-1th position is the kth largest sequence sum in the positive array
Step 3: Prove the correctness of this construction method
First, we need to prove that this construction method covers all subsequences. This is intuitively easy to understand. Let's consider that if all subsequences ending with nums[0], nums[1], ... nums[i-1] have been generated, can we generate all subsequences ending with nums[i] using the method defined previously? Suppose a subsequence ending with nums[i] has an arbitrary nums[k] as its penultimate element. Then we can definitely get it by performing operation 2 on a subsequence ending with nums[k] and then repeatedly performing operation 1.

Secondly, we need to prove that this construction method will not generate repeated subsequences. This is also obvious. For any sequence of the form {X,X,...,X,nums[k],nums[i]}, if k+1==i, then it must be uniquely obtained by a subsequence of the form {X,X,...,X,nums[k]} through operation 2; if k+1!=i, then it must be uniquely obtained by a subsequence of the form {X,X,...,X,nums[k],nums[i-1]} through operation 1.

Finally, we need to prove that the subsequences generated by this construction method are increasing in accordance with and. This proof is very concise. Suppose a sequence A is smaller than sequence B, but B is popped out of the queue first. Is this possible? Note that this means that when B is in the queue, A must not have been added to the queue (otherwise PQ will pop A first). Since A is not in the queue, it means that A's predecessor state A' (the previous paragraph proved that there is only one A') must not be in the queue, because A' is smaller than A. If A' is in the queue, it will be popped out before B, which will cause A to be imported into the queue. Similarly, A''s predecessor sequence A'' will not be in the queue, and A''''s predecessor sequence will not be in the queue... But all sequences start from {nums[0]}, so has this sequence never been added to the queue? This leads to a contradiction.

In summary, we have proved that this construction method will pop out the sum of all subsequences in ascending order without missing any and without duplication. Obviously, the sum of the k-1th smallest subsequence is the sum of the kth smallest subsequence (considering the empty set).
*/

class Solution {
public:
    long long kSum(vector<int>& nums, int k) {
        long long S = 0;
        vector<int> arr(nums.size());
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] > 0) S += nums[i], arr[i] = nums[i];
            else arr[i] = abs(nums[i]);
        }
        sort(arr.begin(), arr.end());
        long long sum = 0;
        priority_queue<pair<long long,int>,vector<pair<long long,int>>,greater<pair<long long,int>>> q;
        q.push({arr[0], 0});
        k--;
        while (k--) {
            auto p = q.top();
            q.pop();
            sum = p.first;
            int i = p.second;
            if (i + 1 < arr.size()) {
                q.push({sum - arr[i] + arr[i + 1], i + 1});
                q.push({sum + arr[i + 1], i + 1});
            }
        }
        return S - sum;
    }
};